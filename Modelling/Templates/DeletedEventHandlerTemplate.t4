<#@ Include File="TemplateHeader.t4" #>
<#@ Modeling ElementType="Microsoft.VisualStudio.Uml.Classes.IClass" Processor="ModelingProcessor" ApplyStereotypes="CSharp" #>
<#@ Import Namespace="Microsoft.VisualStudio.ArchitectureTools.Extensibility.Uml" #>
<#@ Import Namespace="Microsoft.VisualStudio.Uml.AuxiliaryConstructs" #>
<#@ import namespace="Microsoft.VisualStudio.Uml.Classes" #>
<#@ Include File="CSharpCommentHelpers.t4" #>
<#@ Include File="CSharpHelpers.t4" #>
<#@ Include File="CqrsTemplateHelpers.t4" #>
<#@ Include File="ModelHelper.t4" #>
<#@ Output Extension=".cs" #>
<#
var stereoTypeProperties = this.Element.AppliedStereotypes.Single(property => property.Name == "AggregateRoot");
string authenticationTokenType = GetDomainAuthenticationTokenType(this.Element);

// Header
WriteAutoGeneratedWarningHeader();

string classNamespace = GetNamespace(this.Element.Namespace);
string className = ClassifierName(this.Element);

// using statements
#>
using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using cdmdotnet.AutoMapper;
using cdmdotnet.Logging;
using Cqrs.Events;
using Cqrs.Domain;
using <#= classNamespace #>.Entities;
using <#= classNamespace #>.Events;
using <#= classNamespace #>.Repositories;

namespace <#= classNamespace #>.Handlers
{
<#
	// Class and Attributes
#>
	// <#= GetGeneratedCodeAttribute() #>
	public <#= GetAbstract(this.Element) #> partial class <#= className #>EventHandler : IEventHandler<<#= authenticationTokenType #>, <#= className #>Deleted>
	{
<#
	string eventName = className + "Deleted";
	string entityName = className;
#>

		#region Implementation of IEventHandler<in <#= eventName #>>

		public void Handle(<#= eventName #> @event)
		{
			string eventTypeName = @event.GetType().FullName;
			OnHandle(@event);

			var entities = new List<<#= entityName #>Entity>();

			bool singleItemNotCollection = true;
			OnPreGet(@event, ref singleItemNotCollection);
			if (singleItemNotCollection)
			{
				<#= entityName #>Entity entity = null;
				OnGetEntity(@event, ref entity);
				if (entity == null)
				{
					Guid? rsn = null;
					bool throwExceptionOnMissingEntity = true;
					GetSingleEntityRsn(@event, ref rsn, ref throwExceptionOnMissingEntity);
					if (rsn == null)
						rsn = @event.Rsn;
					else
						Logger.LogDebug(string.Format("Event type '{0}' with Rsn '{1:N}': Rsn manually provided.", eventTypeName, @event.Rsn));
					if (!throwExceptionOnMissingEntity)
						Logger.LogDebug(string.Format("Event type '{0}' with Rsn '{1:N}': Can expect no value from the repository without an exception.", eventTypeName, @event.Rsn));
					entity = <#= className #>Repository.Load(rsn.Value, throwExceptionOnMissingEntity);
				}
				else
					Logger.LogDebug(string.Format("Event type '{0}' with Rsn '{1:N}': Entity manually provided.", eventTypeName, @event.Rsn));
				OnGotEntity(@event, ref entity);
				entities.Add(entity);
			}
			else
			{
				Logger.LogDebug(string.Format("Event type '{0}' with Rsn '{1:N}': Several entities will be loaded manually.", eventTypeName, @event.Rsn));
				IEnumerable<<#= entityName #>Entity> manualEntities = null;
				OnGetEntities(@event, ref manualEntities);
				if (manualEntities != null)
					entities.AddRange(manualEntities);
			}
			for (int i = 0; i < entities.Count; i++)
			{
				<#= entityName #>Entity entity = entities[i];

				bool autoMap = false;
				OnDeleteEntity(@event, ref entity, ref autoMap);
				if (autoMap)
					AutomapHelper.Automap(@event, entity);
				else
					Logger.LogDebug(string.Format("Event type '{0}' with Rsn '{1:N}': Is not auto-mapped.", eventTypeName, @event.Rsn));

				entity.IsLogicallyDeleted = true;

				OnEntityDeleted(@event, ref entity);

				bool continueWithRepositorySave = true;
				bool deleteDontUpdate = false;
				OnSaveEntity(@event, ref entity, ref continueWithRepositorySave, ref deleteDontUpdate);
				if (continueWithRepositorySave)
				{
					if (deleteDontUpdate)
					{
						<#= className #>Repository.Delete(entity);
						Logger.LogDebug(string.Format("Event type '{0}' with Rsn '{1:N}': Deleted in repository.", eventTypeName, @event.Rsn));
					}
					else
					{
						<#= className #>Repository.Update(entity);
						Logger.LogDebug(string.Format("Event type '{0}' with Rsn '{1:N}': Updated in repository.", eventTypeName, @event.Rsn));
					}
				}
				else
					Logger.LogDebug(string.Format("Event type '{0}' with Rsn '{1:N}': Not auto-saving.", eventTypeName, @event.Rsn));
				OnEntitySaved(@event, ref entity);
			}
			OnHandled(@event);
		}

		#endregion

		#region Implementation of IEventHandler<in <#= eventName #>> Partials

		partial void OnHandle(<#= eventName #> @event);

		partial void OnPreGet(<#= eventName #> @event, ref bool singleItemNotCollection);

		partial void GetSingleEntityRsn(<#= eventName #> @event, ref Guid? rsn, ref bool throwExceptionOnMissingEntity);

		partial void OnGetEntities(<#= eventName #> @event, ref IEnumerable<<#= entityName #>Entity> manualEntities);

		partial void OnGetEntity(<#= eventName #> @event, ref <#= entityName #>Entity entity);

		partial void OnGotEntity(<#= eventName #> @event, ref <#= entityName #>Entity entity);

		partial void OnDeleteEntity(<#= eventName #> @event, ref <#= entityName #>Entity entity, ref bool autoMap);

		partial void OnEntityDeleted(<#= eventName #> @event, ref <#= entityName #>Entity entity);

		partial void OnSaveEntity(<#= eventName #> @event, ref <#= entityName #>Entity entity, ref bool continueWithRepositorySave, ref bool deleteDontUpdate);

		partial void OnEntitySaved(<#= eventName #> @event, ref <#= entityName #>Entity entity);

		partial void OnHandled(<#= eventName #> @event);

		#endregion
	}
}
<#+
	protected override bool AppliesToElement()
	{
		var stereoTypeProperties = this.Element.AppliedStereotypes.Where(property => property.Name == "AggregateRoot");
		return ShouldGenerateCodeForElement(this.Element) && stereoTypeProperties.Any() && stereoTypeProperties.Single().PropertyInstances
			.Single(property => property.Name == "BuildDeleteCommand")
			.Value == "true";
	}
#>