<#@ Include File="TemplateHeader.t4" #>
<#@ Modeling ElementType="Microsoft.VisualStudio.Uml.Classes.IInterface" Processor="ModelingProcessor" ApplyStereotypes="CSharp" #>
<#@ Import Namespace="System.Linq" #>
<#@ Import Namespace="System.Text" #>
<#@ Import Namespace="Microsoft.VisualStudio.ArchitectureTools.Extensibility.Uml" #>
<#@ Import Namespace="Microsoft.VisualStudio.Uml.Classes" #>
<#@ Include File="CSharpCommentHelpers.t4" #>
<#@ Include File="CSharpHelpers.t4" #>
<#@ Output Extension=".cs" #>
<# 
    WriteAutoGeneratedWarningHeader();

    IInterface interfaceElement = this.Element as IInterface;
    string interfaceNamespace = GetNamespace(interfaceElement.Namespace);
    if(!string.IsNullOrEmpty(interfaceNamespace))
    {
#>
namespace <#= interfaceNamespace #>
{
<#
        PushIndent("\t");
    }

    // Generate using statements
    WriteUsingStatements(interfaceElement);
    WriteLine("");
    WriteSummaryComment(interfaceElement.Description);
    WriteTemplateTypeParameterComments(TemplateParameterNameDescriptionPairs(interfaceElement));
    foreach(var comment in this.Element.GetModelStore().AllInstances<IComment>().Where(c => c.AnnotatedElements.Contains(this.Element)))
    {
        WriteRemarksComment(comment.Body);
    }
#>
<#
    WriteInterfaceClrAttributes(interfaceElement);
#>
<#= InterfaceVisibility(interfaceElement) #><#= InterfaceUnsafeOption(interfaceElement) #><#= InterfacePartialOption(interfaceElement) #>interface <#= ClassifierName(interfaceElement) #> <#= DerivationList(interfaceElement) #><# WriteClassifierConstraintOption(interfaceElement); #>
{
<#
    PushIndent("\t");
	var ownedAttributes = interfaceElement.OwnedAttributes;
    foreach (IProperty property in ownedAttributes)
    {
        if(GetStereotype(property) == "property")
        {
            WriteSummaryComment(property.Description);
            WritePropertyClrAttributes(property);
            WriteInterfacePropertyDeclaration(property);
	        WriteLine("");
        }
    }
    
	// Write Associations; Generate a property for each navigable association.
	var navigableOwnedEnds = GetNavigableOwnedEnds(interfaceElement, ownedAttributes);
    foreach(IProperty ownedEnd in navigableOwnedEnds) 
    {
        WriteSummaryComment(ownedEnd.OwningAssociation.Description);
        WritePropertyClrAttributes(ownedEnd);
        WriteInterfacePropertyDeclaration(ownedEnd);
        WriteLine("");
    }

    foreach (IOperation operation in interfaceElement.OwnedOperations)
    {
        WriteSummaryComment(operation.Description);
        foreach (IParameter parameter in operation.OwnedParameters.Where(p => p.Direction != ParameterDirectionKind.Return))
        {
            WriteParameterComment(parameter.Name, parameter.Description);
        }

        if(GetStereotype(operation) == "method")
        {
            WriteMethodClrAttributes(operation);
#>
<#= MethodUnsafeOption(operation) #><#= MethodType(operation) #> <#= operation.Name #>(<# WriteMethodParameterList(operation); #>);
<#
            WriteLine("");
        }
        else if(GetStereotype(operation) == "indexer") 
        {
            WriteIndexerClrAttributes(operation);
#>
<#= IndexerUnsafeOption(operation) #><#= IndexerType(operation) #> this[<# WriteIndexerParameterList(operation); #>] <# WriteInterfaceIndexerBody(operation); #>
<#
			WriteLine("");
        }
    } 

    PopIndent();
#>
}
<# 
    if(!string.IsNullOrEmpty(interfaceNamespace))
    {
        PopIndent();
#>
}
<#
    }
#>

<#+
    /// <summary>
    /// Returns the visibility of the given interface
    /// </summary>
    /// <param name="anInterface">an interface</param>
    /// <returns>public, protected, protected internal, internal, or private</returns>
    private static string InterfaceVisibility(IInterface anInterface)
    {
        return Visibility(anInterface, "interface", "PackageVisibility");
    }

    /// <summary>
    /// Get list of interfaceElement's derived interfaces, formatted such that 
    /// it can be appended to an interface declaration.
    /// </summary>
    /// <param name="interfaceElement"></param>
    /// <returns>a string listing zero or more interfaces from which interfaceElement is derived.</returns>
    public static string DerivationList(IInterface interfaceElement)
    {
        string text = string.Empty;

        int count = 0;
        foreach (IInterface general in InheritedInterfaces(interfaceElement))
        {
            text += (count++ == 0) ? " : " : ", ";
            text += ElementType(general);
        }

        return text;
    }

    /// <summary>
    /// Gets the list of interfaces inherited by the specified element
    /// </summary>
    /// <param name="element">the interface to query</param>
    /// <returns>list of inherited interfaces</returns>
    private static List<IInterface> InheritedInterfaces(IInterface element)
    {
        List<IInterface> inheritedInterfaces = new List<IInterface>();

        foreach (IGeneralization generalization in element.Generalizations)
        {
            IInterface general = generalization.General as IInterface;
            if (general != null)
            {
                inheritedInterfaces.Add(general);
            }
        }

        return inheritedInterfaces;
    }

    /// <summary>
    /// Writes an indexer body for interface.
    /// </summary>
    /// <param name="operation">The operation for which to generate code</param>
    private void WriteInterfaceIndexerBody(IOperation operation)
    {
        WriteLine("{ get; set; }");
    }

    /// <summary>
    /// Writes a propery definition appropriate for an interface.
    /// </summary>
    /// <param name="property">model element for which to generate code</param>
    private void WriteInterfacePropertyDeclaration(IProperty property)
    {
        Write(PropertyUnsafeOption(property));
        WritePropertyTypeAndVariableName(property, /*isEndOfLine=*/false);
        Write(" { ");
        Write(PropertyGetVisibility(property) + "get;");
        if(!property.IsReadOnly)
        {
            Write(PropertySetVisibility(property) + "set;");
        }
        WriteLine(" }");
    }
#>
<#+
    protected override bool AppliesToElement()
    {
         bool isTemplate = this.Element.IsTemplate;
         bool isBoundElement = this.Element.TemplateBindings != null && this.Element.TemplateBindings.Any();
         return !isTemplate && !isBoundElement && GetStereotype(this.Element) == "interface";
    }
#>
