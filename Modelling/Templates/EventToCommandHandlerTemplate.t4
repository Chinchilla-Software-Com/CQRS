<#@ Include File="TemplateHeader.t4" #>
<#@ Modeling ElementType="Microsoft.VisualStudio.Uml.Classes.IAssociation" Processor="ModelingProcessor" ApplyStereotypes="CSharp" #>
<#@ Import Namespace="Microsoft.VisualStudio.ArchitectureTools.Extensibility.Uml" #>
<#@ Import Namespace="Microsoft.VisualStudio.Uml.AuxiliaryConstructs" #>
<#@ import namespace="Microsoft.VisualStudio.Uml.Classes" #>
<#@ Include File="CSharpCommentHelpers.t4" #>
<#@ Include File="CSharpHelpers.t4" #>
<#@ Include File="CqrsTemplateHelpers.t4" #>
<#@ Include File="ModelHelper.t4" #>
<#@ Output Extension=".cs" #>
<#
var stereoTypeProperties = this.Element.AppliedStereotypes.Single(property => property.Name == "EventToCommandConverter");
string authenticationTokenType = GetDomainAuthenticationTokenType(this.Element);

// Header
WriteAutoGeneratedWarningHeader();

string classNamespace = GetNamespace(this.Element.Namespace);
string className = ClassifierName(this.Element);
string baseClass = string.Empty;
IElement eventElement = this.Element.SourceElement;
IElement commandElement = this.Element.TargetElement;
string eventName = ClassifierName(eventElement as IClassifier);
string eventParameterType = GetFullDisplayType(this.Element.MemberEnds.Single(x => x.Type == commandElement), editableCollection: true);
bool isEventParameterTypeACollection = eventParameterType.StartsWith("IList<");
string commandName = string.Format("{2}{0}.{1}Command{3}", GetNamespace((commandElement as IClassifier).Namespace), ClassifierName(commandElement as IClassifier), isEventParameterTypeACollection ? "IList<" : null, isEventParameterTypeACollection ? ">" : null);
string crefName = isEventParameterTypeACollection ? "IList{" + ClassifierName(commandElement as IClassifier) + "}" : ClassifierName(commandElement as IClassifier);

string aggregateTechnology = GetAggregateTechnology(FindDomainElement(this.Element));
string commandSender;
switch(aggregateTechnology)
{
	case "Akka":
		commandSender = "Cqrs.Akka.Commands.IAkkaCommandSender";
		break;
	default:
		commandSender = "ICommandPublisher";
		break;
}


// using statements
#>
using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Linq;
<#
string eventHandlerTechnology = GetEventHandlerTechnology(this.Element);
switch(eventHandlerTechnology)
{
	case "Akka":
#>using Akka.Actor;
using Cqrs.Akka.Domain;
using Cqrs.Akka.Events;
using Cqrs.Authentication;
<#
		break;
	default:
		// for now do nothing
		break;
}
#>
using cdmdotnet.AutoMapper;
using cdmdotnet.Logging;
using Cqrs.Commands;
using Cqrs.Events;
using Cqrs.Domain;

namespace <#= classNamespace #>.Handlers
{
<#
	// Class and Attributes
	string eventHandlerTechnologyBaseClass = "IEventHandler<" + authenticationTokenType + ", " + eventName + ">";
	eventHandlerTechnologyBaseClass = ": " + eventHandlerTechnologyBaseClass;
#>
	/// <summary>
	/// Converts <see cref="<#= eventName #>"/> to a <see cref="<#= crefName #>"/> and publish it using <see cref="CommandBus"/>
	/// </summary>
	<#= GetGeneratedCodeAttribute() #>
	public partial class <#= className #>EventToCommandHandler
		<#= eventHandlerTechnologyBaseClass #>
	{
		protected ILogger Logger { get; private set; }

		protected IAutomapHelper AutomapHelper { get; private set; }

		/// <summary>
		/// Instantiates the <see cref="<#= className #>EventToCommandHandler"/> class.
		/// </summary>
		public <#= className #>EventToCommandHandler(ILogger logger, IAutomapHelper automapHelper)
		{
			Logger = logger;
			AutomapHelper = automapHelper;
		}

<#
switch(eventHandlerTechnology)
{
	case "Akka":
#>
		protected IAkkaAggregateResolver AggregateResolver { get; private set; }

		/// <summary>
		/// Instantiates the <see cref="<#= className #>EventToCommandHandler"/> class registering any <see cref="ReceiveActor.Receive{T}(System.Func{T,System.Threading.Tasks.Task})"/> required.
		/// </summary>
		public <#= className #>EventToCommandHandler(IAkkaAggregateResolver aggregateResolver, ILogger logger, IAutomapHelper automapHelper)
			: this (logger, automapHelper)
		{
			AggregateResolver = aggregateResolver;
		}
<#
		break;
	default:
#>
		protected ICommandPublisher<<#= authenticationTokenType #>> CommandBus { get; private set; }

		/// <summary>
		/// Instantiates the <see cref="<#= className #>EventToCommandHandler"/> class.
		/// </summary>
		public <#= className #>EventToCommandHandler(<#= commandSender #><<#= authenticationTokenType #>> commandBus, ILogger logger, IAutomapHelper automapHelper)
			: this (logger, automapHelper)
		{
			CommandBus = commandBus;
		}
<#
		break;
}
#>

<#
switch(eventHandlerTechnology)
{
	case "Akka":
#>

		#region Implementation of IMessageHandler<in <#= eventName #>>

		public void Handle(<#= eventName #> @event)
		{
			global::Akka.Actor.IActorRef item = AggregateResolver.ResolveActor<Actor>();
			// bool result = global::Akka.Actor.Futures.Ask<bool>(item, @event).Result;
			global::Akka.Actor.ActorRefImplicitSenderExtensions.Tell(item, @event);
		}

		#endregion

		public partial class Actor
			: AkkaEventHandler<<#= authenticationTokenType #>>
		{
			protected ICommandPublisher<<#= authenticationTokenType #>> CommandBus { get; private set; }

			#region Implementation of IEventHandler<in <#= className #>>

			/// <summary>
			/// Convert the provided <paramref name="@event"/> to a <see cref="<#= crefName #>"/> and publish it using <see cref="CommandBus"/>
			/// </summary>
			public virtual void Handle(<#= eventName #> @event)
			{
				<#= commandName #> command = null;
				OnHandle(@event, ref command);
				if (command != null)
					CommandBus.Publish(command);
				OnHandled(@event);
			}

			#endregion

			partial void OnHandle(<#= eventName #> @event, ref <#= commandName #> command);

			partial void OnHandled(<#= eventName #> @event);

			public Actor(ILogger logger, ICorrelationIdHelper correlationIdHelper, IAuthenticationTokenHelper<<#= authenticationTokenType #>> authenticationTokenHelper, <#= commandSender #><<#= authenticationTokenType #>> commandBus)
				: base(logger, correlationIdHelper, authenticationTokenHelper)
			{
				CommandBus = commandBus;
				Receive<<#= eventName #>>(@event => Execute(Handle, @event));
			}
		}
<#
		break;
	default:
#>

		#region Implementation of IEventHandler<in <#= className #>>

		/// <summary>
		/// Convert the provided <paramref name="@event"/> to a <see cref="<#= crefName #>"/> and publish it using <see cref="CommandBus"/>
		/// </summary>
		public virtual void Handle(<#= eventName #> @event)
		{
			<#= commandName #> command<#= isEventParameterTypeACollection ? "s" : null #> = <#= isEventParameterTypeACollection ? "new " + commandName.Substring(1) + "()" : "null" #>;
			OnHandle(@event, ref command<#= isEventParameterTypeACollection ? "s" : null #>);
			if (command<#= isEventParameterTypeACollection ? "s" : null #> != null)
				CommandBus.Publish(command<#= isEventParameterTypeACollection ? "s.AsEnumerable()" : null #>);
			OnHandled(@event);
		}

		#endregion

		partial void OnHandle(<#= eventName #> @event, ref <#= commandName #> command<#= isEventParameterTypeACollection ? "s" : null #>);

		partial void OnHandled(<#= eventName #> @event);
<#
		break;
}
#>
	}
}
<#+
	protected override bool AppliesToElement()
	{
		return ShouldGenerateCodeForElement(this.Element) && this.Element.AppliedStereotypes.Any(property => property.Name == "EventToCommandConverter");
	}
#>