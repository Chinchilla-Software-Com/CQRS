<#@ Include File="TemplateHeader.t4" #>
<#@ Modeling ElementType="Microsoft.VisualStudio.Uml.Classes.IClass" Processor="ModelingProcessor" ApplyStereotypes="CSharp" #>
<#@ Import Namespace="Microsoft.VisualStudio.ArchitectureTools.Extensibility.Uml" #>
<#@ Import Namespace="Microsoft.VisualStudio.Uml.AuxiliaryConstructs" #>
<#@ import namespace="Microsoft.VisualStudio.Uml.Classes" #>
<#@ Include File="CSharpCommentHelpers.t4" #>
<#@ Include File="CSharpHelpers.t4" #>
<#@ Include File="CqrsTemplateHelpers.t4" #>
<#@ Include File="ModelHelper.t4" #>
<#@ Output Extension=".cs" #>
<#
var stereoTypeProperties = this.Element.AppliedStereotypes.Single(property => property.Name == "AggregateRoot");
string authenticationTokenType = GetDomainAuthenticationTokenType(this.Element);

bool hasRepository= stereoTypeProperties.PropertyInstances
	.Any(property => property.Name == "BuildRepository" && property.Value == "true");
if (hasRepository)
	hasRepository = this.Element.AppliedStereotypes.Any(property => property.Name == "Entity");

// Header
WriteAutoGeneratedWarningHeader();

string classNamespace = GetNamespace(this.Element.Namespace);
string className = ClassifierName(this.Element);

string areaName = classNamespace.Substring(classNamespace.LastIndexOf(".") + 1);

// using statements
WriteUsingStatements(this.Element);
#>
using System;
using System.Collections.Generic;
using System.Web.Http;

using cdmdotnet.Logging;
using Cqrs.Authentication;
using Cqrs.Commands;
using Cqrs.Events;
using Cqrs.Repositories.Queries;
using Cqrs.Services;
using Cqrs.WebApi;

using <#= classNamespace #>;
using <#= classNamespace #>.Commands;
using <#= classNamespace #>.Repositories;
using <#= classNamespace #>.Services;

namespace <#= classNamespace #>.Controllers
{
<#
	// Class and Attributes
#>
	/// <summary>
	/// An <see cref="CqrsEventApiController{TSingleSignOnToken}">API controller</see> for all publically exposed <see cref="<#= className #>"><#= className #></see> methods and queries.
	/// <see cref="<#= className #>"><#= className #></see> is described as:
	/// <#= this.Element.Description #>
	/// </summary>
	/// <remarks>
	/// Ensure you include the nuget package Cqrs.WebApi.
	/// For automatic help documentation generation visit 
	/// https://www.asp.net/web-api/overview/getting-started-with-aspnet-web-api/creating-api-help-pages
	/// and start at the section "Adding Help Pages to an Existing Project".
	/// Then enable XML documentation for all projects for both DEBUG and RELEASE builds.
	/// </remarks>
	<#= GetGeneratedCodeAttribute() #>
	[RoutePrefix("<#= areaName #>/<#= className #>")]
	public <#= GetAbstract(this.Element) #> partial class <#= className #>Controller
		: CqrsEventApiController<<#= authenticationTokenType #>>
		, I<#= className #>Service
	{
		protected ICommandPublisher<<#= authenticationTokenType #>> CommandPublisher { get; private set; }

		protected IUnitOfWorkService UnitOfWorkService { get; private set;}
<# if (hasRepository) { #>

		protected I<#= className #>Repository <#= className #>Repository { get; private set; }
<# } #>

		protected IQueryFactory QueryFactory { get; private set; }

		/// <summary>
		/// Instantiate a new instance of the <see cref="<#= className #>Controller"/> class
		/// </summary>
		public <#= className #>Controller(ILogger logger, ICorrelationIdHelper correlationIdHelper, IAuthenticationTokenHelper<<#= authenticationTokenType #>> authenticationTokenHelper, IEventStore<<#= authenticationTokenType #>> eventStore, ICommandPublisher<<#= authenticationTokenType #>> commandPublisher, IUnitOfWorkService unitOfWorkService, IQueryFactory queryFactory<# if (hasRepository) { #>, I<#= className #>Repository <#= GetLowercaseFirstCharacter(className) #>Repository<# } #>)
			: base(logger, correlationIdHelper, authenticationTokenHelper, eventStore)
		{
			CommandPublisher = commandPublisher;
			UnitOfWorkService = unitOfWorkService;
			QueryFactory = queryFactory;
<# if (hasRepository) { #>
			<#= className #>Repository = <#= GetLowercaseFirstCharacter(className) #>Repository;
<# } #>
		}
<#
		IEnumerable<IAssociation> relationships = this.Element.GetRelatedLinks<IAssociation>().Where(associationEnd => !string.IsNullOrWhiteSpace(associationEnd.Name) && associationEnd.TargetElement == this.Element);

		foreach(IAssociation relationship in relationships)
		{
			string relationshipName = relationship.Name;
			bool isAutoGeneratedCrud = ((relationshipName == "Create" + className || relationshipName == "Update" + className || relationshipName == "Delete" + className) && relationship.SourceElement.AppliedStereotypes.Any(property => property.Name == "AutoGenerated"));
			if (string.IsNullOrWhiteSpace(relationshipName))
				relationshipName = ((INamedElement)relationship.SourceElement).Name;
			string targetElementName = ((INamedElement)relationship.TargetElement).Name;
			string sourceElementName = ((INamedElement)relationship.SourceElement).Name;
			IList<IProperty> relationshipProperties = GetPropertyList((IClass)relationship.SourceElement).Where(property=> property.Type != relationship.TargetElement && property.Type != relationship.SourceElement).ToList();
			IEnumerable<IAssociation> eventRelationships = this.Element.GetRelatedLinks<IAssociation>().Where(associationEnd => associationEnd.Name == relationship.Name && associationEnd.SourceElement == this.Element);

			string parameterName = string.Format(isAutoGeneratedCrud ? "Entities.{0}Entity" : "{0}{1}Parameters", className, relationshipName);
			string parameterVariableName = isAutoGeneratedCrud ? "entity" : "parameters";
			string responseDataType = (isAutoGeneratedCrud && (relationshipName == "Create" + className || relationshipName == "Update" + className)) ? "IServiceResponseWithResultData<" + parameterName + ">" : "IServiceResponse";
			string responseDataTypeConstructor = (isAutoGeneratedCrud && (relationshipName == "Create" + className || relationshipName == "Update" + className)) ? "ServiceResponseWithResultData<" + parameterName + ">" : "ServiceResponse";
#>

		#region <#= relationshipName #>

<# WriteSummaryComment(string.IsNullOrWhiteSpace(relationship.Description) ? ((INamedElement)relationship.SourceElement).Description : relationship.Description) ; #>
		[Route("<#= relationshipName #>")]
<#
			string httpMethodAttributeValue= "HttpPost";
			if (isAutoGeneratedCrud)
			{
				if (relationshipName == "Delete" + className)
				{
					httpMethodAttributeValue= "HttpDelete";
#>
		[Route("{rsn:guid}")]
<#
				}
				else if (relationshipName == "Create" + className)
				{
#>
		[Route("")]
<#
				}
				else if (relationshipName == "Update" + className)
				{
					httpMethodAttributeValue= "HttpPatch";
#>
		[Route("{rsn:guid}")]
<#
				}
			}
#>
		[<#= httpMethodAttributeValue #>]
		public virtual <#= responseDataType #> <#= relationshipName #>([FromBody]<#= parameterName #> <#= parameterVariableName #>)
		{
			return <#= relationshipName #>(CreateRequestWithData<<#= authenticationTokenType #>, <#= parameterName #>>(() => <#= parameterVariableName #>));
		}

		<#= responseDataType #> I<#= className #>Service.<#= relationshipName #>(IServiceRequestWithData<<#= authenticationTokenType #>, <#= parameterName #>> serviceRequest)
		{
			return <#= relationshipName #>(serviceRequest);
		}

<# WriteSummaryComment(string.IsNullOrWhiteSpace(relationship.Description) ? ((INamedElement)relationship.SourceElement).Description : relationship.Description) ; #>
		protected virtual <#= responseDataType #> <#= relationshipName #>(IServiceRequestWithData<<#= authenticationTokenType #>, <#= parameterName #>> serviceRequest)
		{
			Logger.LogDebug("Entered", "<#= className #>/<#= relationshipName #>");

			AuthenticationTokenHelper.SetAuthenticationToken(serviceRequest.AuthenticationToken);
			CorrelationIdHelper.SetCorrelationId(serviceRequest.CorrelationId);
			UnitOfWorkService.SetCommitter(this);
			<#= parameterName #> item = serviceRequest.Data;

			var command = new <#= sourceElementName #><#= isAutoGeneratedCrud ? string.Empty : "Command" #>(<#

			var relationshipStereoTypeProperties = relationship.SourceElement.AppliedStereotypes.Single(property => property.Name == "Command");
			bool createsNewInstance = relationshipStereoTypeProperties.PropertyInstances.Any(property => property.Name == "CreatesNewInstance" && property.Value == "true");
#>rsn: <#=createsNewInstance ? "Guid.NewGuid()" : "item.Rsn" #><#
			for (int i = 0; i < relationshipProperties.Count; i++)
			{
				IProperty relationshipProperty = relationshipProperties.ElementAt(i);
				#>, <#= GetLowercaseFirstCharacter(relationshipProperty.Name) #>: item.<#= relationshipProperty.Name #><#
			}
#>);
<#
			if (isAutoGeneratedCrud && createsNewInstance)
			{
#>			item.Rsn = command.Rsn;
<#
			}
#>
			ServiceResponseStateType? serviceResponseStateType = null;
			Logger.LogDebug("Pre", "<#= className #>/<#= relationshipName #>/On<#= relationshipName #>");
			On<#= relationshipName #>(serviceRequest, ref command, ref serviceResponseStateType);
			Logger.LogDebug("Post", "<#= className #>/<#= relationshipName #>/On<#= relationshipName #>");
			if (serviceResponseStateType != null && serviceResponseStateType != ServiceResponseStateType.Succeeded)
				return CompleteResponse(new <#= responseDataTypeConstructor #> { State = serviceResponseStateType.Value });

			Logger.LogDebug("Pre", "<#= className #>/<#= relationshipName #>/PublishCommand");
			CommandPublisher.Publish(command);
			Logger.LogDebug("Post", "<#= className #>/<#= relationshipName #>/PublishCommand");
			Logger.LogDebug("Pre", "<#= className #>/<#= relationshipName #>/On<#= relationshipName #>Handled");
			On<#= relationshipName #>Handled(serviceRequest, ref command, ref serviceResponseStateType);
			Logger.LogDebug("Post", "<#= className #>/<#= relationshipName #>/On<#= relationshipName #>Handled");
			if (serviceResponseStateType != null && serviceResponseStateType != ServiceResponseStateType.Succeeded)
				return CompleteResponse(new <#= responseDataTypeConstructor #> { State = serviceResponseStateType.Value });

			UnitOfWorkService.Commit(this);

			Logger.LogDebug("Exited", "<#= className #>/<#= relationshipName #>");
			return CompleteResponse(new <#= responseDataTypeConstructor #>(<#= (isAutoGeneratedCrud && (relationshipName == "Create" + className || relationshipName == "Update" + className)) ? "item" : string.Empty #>));
		}

		partial void On<#= relationshipName #>(IServiceRequestWithData<<#= authenticationTokenType #>, <#= parameterName #>> serviceRequest, ref <#= sourceElementName #><#= isAutoGeneratedCrud ? string.Empty : "Command" #> command, ref ServiceResponseStateType? serviceResponseStateType);

		partial void On<#= relationshipName #>Handled(IServiceRequestWithData<<#= authenticationTokenType #>, <#= parameterName #>> serviceRequest, ref <#= sourceElementName #><#= isAutoGeneratedCrud ? string.Empty : "Command" #> command, ref ServiceResponseStateType? serviceResponseStateType);

		#endregion
<#
		}
#>

		/// <summary>
		/// Query for all the events that match the provided CorrelationId.
		/// </summary>
		/// <param name="correlationId">The CorrelationId of the matching events.</param>
		/// <returns>A <see cref="IServiceResponseWithResultData{TResultData}">service-response</see> with a collection of <see cref="EventData">event data</see></returns>
		[Route("GetEventData/{correlationId:guid}")]
		[HttpGet]
		public virtual IServiceResponseWithResultData<IEnumerable<EventData>> GetEventData(Guid correlationId)
		{
			return GetEventData(CreateRequestWithData<<#= authenticationTokenType #>, Guid>(() => correlationId));
		}
	}
}
<#+
	protected override bool AppliesToElement()
	{
		return ShouldGenerateCodeForElement(this.Element) && this.Element.AppliedStereotypes.Any(property => property.Name == "AggregateRoot");
	}
#>